import java.text.MessageFormat

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'mysql:mysql-connector-java:5.1.41'
    }
}

plugins {
    id 'org.flywaydb.flyway' version '4.2.0'
    id 'com.jfrog.artifactory' version '4.4.18'
}

apply plugin: 'distribution'
apply plugin: 'maven-publish'

group = 'org.opentestsystem.rdw.schema'
version = '0.0.1-SNAPSHOT'

if (project.hasProperty("buildNumber")) {
    project.setVersion(project.version.toString().replaceAll("SNAPSHOT", "${buildNumber}"))
}

//Setting up an easy mapping of simple name to task object
def flywayActions = [migrate: org.flywaydb.gradle.task.FlywayMigrateTask,
               clean: org.flywaydb.gradle.task.FlywayCleanTask,
               info: org.flywaydb.gradle.task.FlywayInfoTask,
               validate: org.flywaydb.gradle.task.FlywayValidateTask,
               baseline: org.flywaydb.gradle.task.FlywayBaselineTask,
               repair: org.flywaydb.gradle.task.FlywayRepairTask]

def dataMartSchemas = ["reporting", "staging", "spring_batch_reporting"]
def warehouseSchemas = ["warehouse"]

//Gradle can't call a single task more than once, because of its design, so
//we dynamically create individual tasks for each of the available flyway commands
//on all of our databases (dev and test). Task names end up like migrateStaging and cleanWarehouse_test.
(dataMartSchemas + warehouseSchemas).each { schema ->
    flywayActions.keySet().each { action ->
        ["", "_test"].each { type ->
            task(action + schema.capitalize() + type, type: flywayActions[action]) {
                group = "$action$type"
                url = database_url
                user = database_user
                password = database_password
                driver = 'com.mysql.jdbc.Driver'
                schemas = ["$schema$type"]
                locations = ['filesystem:' + rootDir.path + "/$schema/sql"]
                placeholders = ["schemaName": "$schema$type"]
            }
        }
    }
}

def ts = project.getTasks()
["clean", "migrate"].each { allTask ->
    ["","_test"].each { type ->
        task("${allTask}All$type", dependsOn: [ts.findAll { it.property("group") == "$allTask$type" }]) {
            group = "$allTask$type"
            description = "Custom task to " + allTask.capitalize() + MessageFormat.format(" all objects in the configured {0} schemas.", type ? "test" : "production/development")
        }
        task("${allTask}DataMart$type", dependsOn: [ts.findAll{x-> x.name in dataMartSchemas.collect {allTask + it.capitalize() + type}}]) {
            group = "$allTask$type"
            description = "Custom task to " + allTask.capitalize() +  MessageFormat.format(" all objects in the configured {0} data mart schemas.", type ? "test" : "production/development")
        }
    }
}

//Setup distribution
distributions {
    main {
        contents {
            from ('.') {
                include 'reporting/**'
                include 'warehouse/**'
                include 'staging/**'
                include 'spring_batch_reporting/**'
                include 'LICENSE'
                include 'build.gradle'
                include 'gradle.properties'
            }
        }
    }
}

//define the artifacts - they come from the distZip
publishing {
    publications {
        schema(MavenPublication) {
            artifact distZip
        }
    }
}

//Install task for installing (publishing) to local .m2
task install(dependsOn: publishToMavenLocal)


//For ci use only
artifactory {
    publish {
        repository {
            repoKey = 'libs-releases-local'
            maven = true

        }
        defaults {
            publications('schema')
        }
    }
    resolve {
        repository {
            repoKey = 'libs-releases'
            maven = true

        }
    }
}
