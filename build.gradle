buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'mysql:mysql-connector-java:5.1.41'
    }
}

plugins {
    id 'org.flywaydb.flyway' version '4.2.0'
    id 'com.jfrog.artifactory' version '4.4.18'
}

apply plugin: 'distribution'
apply plugin: 'maven-publish'

group = 'org.opentestsystem.rdw.schema'
version = '0.0.1-SNAPSHOT'

if (project.hasProperty("buildNumber")) {
    project.setVersion(project.version.toString().replaceAll("SNAPSHOT", "${buildNumber}"))
}

//Setting up an easy mapping of simple name to task object
def taskMap = [migrate: org.flywaydb.gradle.task.FlywayMigrateTask,
               clean: org.flywaydb.gradle.task.FlywayCleanTask,
               info: org.flywaydb.gradle.task.FlywayInfoTask,
               validate: org.flywaydb.gradle.task.FlywayValidateTask,
               baseline: org.flywaydb.gradle.task.FlywayBaselineTask,
               repair: org.flywaydb.gradle.task.FlywayRepairTask]

def dataMartSchemas = ["reporting", "reporting_test", "staging", "staging_test", "spring_batch_reporting", "spring_batch_reporting_test"]
def warehouseSchemas = ["warehouse", "warehouse_test"]

//Gradle can't call a single task more than once, because of its design, so
//we dynamically create individual tasks for each of the available flyway commands
//on all of our databases (dev and test)
(dataMartSchemas + warehouseSchemas).each { schema ->
    taskMap.keySet().each { key ->
        task("$key$schema", type: taskMap[key]) {
            group = key

            url = 'jdbc:mysql://localhost:3306/'
            user = 'root'
            password = ''
            driver = 'com.mysql.jdbc.Driver'
            schemas = [schema]
            locations = ['filesystem:' + rootDir.path + '/' + schema.split('_test')[0] + '/sql']
            placeholders = ["schemaName": schema]
        }
    }
}

["clean", "migrate"].each { allTask ->
    def ts = project.getTasks()
    task("${allTask}DataMart", dependsOn: [ts.findAll{x -> !(x.name.contains('warehouse')) &&  !(x.name.contains("_test")) && x.property("group") == allTask}]){
        group=allTask
        description="Custom task to " + allTask.capitalize() + " all objects in the configured production/development data mart schemas."
    }
    task("${allTask}DataMart-test", dependsOn: [ts.findAll{x -> !(x.name.contains('warehouse')) && x.name.contains("_test") && x.property("group") == allTask}]) {
        group = allTask
        description = "Custom task to " + allTask.capitalize() + " all objects in the test data mart schemas."
    }
    task("${allTask}All", dependsOn: [ts.findAll{x-> !(x.name.contains("_test")) && x.property("group") == allTask}]){
        group=allTask
        description="Custom task to " + allTask.capitalize() + " all objects in the configured production/development schemas."
    }
    task("${allTask}All-test", dependsOn: [ts.findAll{x-> x.name.contains("_test") && x.property("group") == allTask}]){
        group=allTask
        description="Custom task to " + allTask.capitalize() + " all objects in the configured test schemas."
    }
}


//Setup distribution
distributions {
    main {
        contents {
            from ('.') {
                include 'reporting/**'
                include 'warehouse/**'
                include 'staging/**'
                include 'spring_batch_reporting/**'
                include 'LICENSE'
                include 'build.gradle'
            }
        }
    }
}

//define the artifacts - they come from the distZip
publishing {
    publications {
        schema(MavenPublication) {
            artifact distZip
        }
    }
}

//Install task for installing (publishing) to local .m2
task install(dependsOn: publishToMavenLocal)


//For ci use only
artifactory {
    publish {
        repository {
            repoKey = 'libs-releases-local'
            maven = true

        }
        defaults {
            publications('schema')
        }
    }
    resolve {
        repository {
            repoKey = 'libs-releases'
            maven = true

        }
    }
}